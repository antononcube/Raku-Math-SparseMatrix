use v6.d;

# use lib <. lib>;
use Math::SparseMatrix::CSR;
use Math::SparseMatrix::Utilities;
use Test;

my $nrow = 5;
my $ncol = 8;
my $density = 0.5;
my $tol = 0.01;

my $matrix1 = generate-random-sparse-matrix(:$nrow, :$ncol, :$density, :$tol):!decorated;
my $matrix2 = generate-random-sparse-matrix(:$nrow, :$ncol, :$density, :$tol):!decorated;

## Too contrived?
sub mult-by-rules($matrix1, $matrix2) {
    my %rules;
    my %r1 = $matrix1.rules;
    my %r2 = $matrix2.rules;
    my @keys = [|%r1.keys, |%r2.keys].unique;

    my $use-iv = !($matrix1.implicit-value == 0 && $matrix2.implicit-value == 0);

    for @keys -> $pos {
        if (%r1{$pos}:exists) && (%r2{$pos}:exists) {
            %rules{$pos} = %r1{$pos} * %r2{$pos};
        } elsif (%r2{$pos}:exists) && $use-iv {
            %rules{$pos} = $matrix1.implicit-value * %r2{$pos};
        } elsif (%r1{$pos}:exists) && $use-iv {
            %rules{$pos} = %r1{$pos} * $matrix2.implicit-value;
        }
    }
    return %rules;
}

plan *;

## 1
isa-ok $matrix1, Math::SparseMatrix::CSR;

## 2
isa-ok $matrix1, Math::SparseMatrix::CSR;

## 3
isa-ok $matrix1.add(4.3), Math::SparseMatrix::CSR;

## 4
isa-ok $matrix1.add($matrix2), Math::SparseMatrix::CSR;

## 5
is-deeply
        $matrix1.multiply($matrix2).rules.Hash,
        mult-by-rules($matrix1, $matrix2),
        "Same rules of mult-by-rules";

## 6
subtest {
    my $matrix1iv = $matrix1.clone;
    $matrix1iv.implicit-value = 1.5;
    my $matrix2iv = $matrix2.clone;
    $matrix2iv.implicit-value = 2.2;
    is-deeply
            $matrix1iv.multiply($matrix2iv).rules.Hash,
            mult-by-rules($matrix1iv, $matrix2iv),
            "Same rules of mult-by-rules";
    is
            $matrix1iv.multiply($matrix2iv).implicit-value,
            $matrix1iv.implicit-value * $matrix2iv.implicit-value,
            "Implicit value";
}, "Multiplication with implicit values";

## 7
subtest {
    my $matrix1iv = $matrix1.clone;
    $matrix1iv.implicit-value = 1.5;
    is-deeply
            $matrix1iv.multiply($matrix2).rules.Hash,
            mult-by-rules($matrix1iv, $matrix2),
            "Same rules of mult-by-rules";
    is
            $matrix1iv.multiply($matrix2).implicit-value,
            0,
            "Implicit value";
}, "Multiplication with non-zero implicit value of one of the matrices";

## 8
subtest {
    my @rules = (0, 2) => 10, (0, 5) => 4, (0, 6) => 2, (0, 9) => 1;
    my $vec = Math::SparseMatrix::CSR.new(:@rules, :1nrow, :16ncol);
    isa-ok $vec, Math::SparseMatrix::CSR:D, 'expected base vector type';

    my @fRules = (0, 2) => 1, (0, 6) => 1;
    my $filter = Math::SparseMatrix::CSR.new(rules => @fRules, :1nrow, :16ncol);
    isa-ok $filter, Math::SparseMatrix::CSR:D, 'expected filter type';

    my $newVec = $filter.multiply($vec);
    isa-ok $newVec, Math::SparseMatrix::CSR:D, 'expected filtered vector type';
    is
            $newVec.rules.sort({ $_.head.tail }).Array,
            [(0, 2) => 10, (0, 6) => 2],
            'expected rules of filtered vector';

    my $negFilter = Math::SparseMatrix::CSR.new(rules => @fRules, :1nrow, :16ncol).multiply(0);
    # This also works:
    #   my $negFilter = $filter.clone.multiply(0);
    $negFilter.implicit-value = 1;
    isa-ok $negFilter, Math::SparseMatrix::CSR:D, 'expected negative filter type';

    my $negNewVec = $negFilter.multiply($vec);
    isa-ok
            $negNewVec,
            Math::SparseMatrix::CSR:D,
            'expected negatively filtered vector type';
    is
            $negNewVec.rules.sort({ $_.head.tail }).Array,
            [(0, 2) => 0, (0, 5) => 4, (0, 6) => 0, (0, 9) => 1],
            'expected rules of negatively filtered vector';

    my $negNewVec2 = $vec.multiply($negFilter);
    isa-ok
            $negNewVec2,
            Math::SparseMatrix::CSR:D,
            'expected negatively filtered vector type, $vec * $negFilter';
    is
            $negNewVec2.rules.sort({ $_.head.tail }).Array,
            [(0, 2) => 0, (0, 5) => 4, (0, 6) => 0, (0, 9) => 1],
            'expected rules of negatively filtered vector, $vec * $negFilter';
}, 'Multiplication as a filter';

done-testing;
