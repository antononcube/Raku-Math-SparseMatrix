use v6.d;

#use lib <. lib>;
use Math::SparseMatrix::DOK;
use Math::SparseMatrix::Utilities;
use Test;

my $nrow = 5;
my $ncol = 8;
my $density = 0.25;
my $tol = 0.01;
my $type = 'DOK';

my $matrix1 = generate-random-sparse-matrix(:$nrow, :$ncol, :$density, :$tol, :$type):!decorated;
my $matrix2 = generate-random-sparse-matrix(:$nrow, :$ncol, :$density, :$tol, :$type):!decorated;


plan *;

## 1
isa-ok $matrix1, Math::SparseMatrix::DOK;

## 2
isa-ok $matrix2, Math::SparseMatrix::DOK;

## 3
isa-ok $matrix1.multiply(4.3), Math::SparseMatrix::DOK;

## 4
isa-ok $matrix1.multiply($matrix2), Math::SparseMatrix::DOK;

## 5
my @arr5 = elementwise-operation($matrix1.Array, $matrix2.Array, &infix:<*>);
is
        elementwise-operation($matrix1.multiply($matrix2).Array, @arr5, &infix:<->).map(*.Slip)>>.abs.max < 1e-12,
        True,
        "Same dense matrix";

## 6
subtest {
    my $matrix1iv = $matrix1.clone;
    $matrix1iv.implicit-value = 1.5;
    my $matrix2iv = $matrix2.clone;
    $matrix2iv.implicit-value = 2.2;
    my @arr = elementwise-operation($matrix1.Array, $matrix2.Array, &infix:<*>);
    is
            elementwise-operation($matrix1.multiply($matrix2).Array, @arr, &infix:<->).map(*.Slip)>>.abs.max < 1e-12,
            True,
            "Same dense matrix";
}, "Multiplication with implicit values";

## 7
subtest {
    my @rules = (0, 2) => 10, (0, 5) => 4, (0, 6) => 2, (0, 9) => 1;
    my $vec = Math::SparseMatrix::DOK.new(:@rules, :1nrow, :16ncol);
    isa-ok $vec, Math::SparseMatrix::DOK:D, 'expected base vector type';

    my @fRules = (0, 2) => 1, (0, 6) => 1;
    my $filter = Math::SparseMatrix::DOK.new(rules => @fRules, :1nrow, :16ncol);
    isa-ok $filter, Math::SparseMatrix::DOK:D, 'expected filter type';

    my $newVec = $filter.multiply($vec);
    isa-ok $newVec, Math::SparseMatrix::DOK:D, 'expected filtered vector type';
    is
            $newVec.rules.sort({ $_.head.tail }).Array,
            [(0, 2) => 10, (0, 5) => 0, (0, 6) => 2, (0, 9) => 0],
            'expected rules of filtered vector';

    my $negFilter = Math::SparseMatrix::DOK.new(rules => @fRules, :1nrow, :16ncol).multiply(0);
    # This also works:
    #   my $negFilter = $filter.clone.multiply(0);
    $negFilter.implicit-value = 1;
    isa-ok $negFilter, Math::SparseMatrix::DOK:D, 'expected negative filter type';

    my $negNewVec = $negFilter.multiply($vec);
    isa-ok
            $negNewVec,
            Math::SparseMatrix::DOK:D,
            'expected negatively filtered vector type';
    is
            $negNewVec.rules.sort({ $_.head.tail }).Array,
            [(0, 2) => 0, (0, 5) => 4, (0, 6) => 0, (0, 9) => 1],
            'expected rules of negatively filtered vector';

    my $negNewVec2 = $vec.multiply($negFilter);
    isa-ok
            $negNewVec2,
            Math::SparseMatrix::DOK:D,
            'expected negatively filtered vector type, $vec * $negFilter';
    is
            $negNewVec2.rules.sort({ $_.head.tail }).Array,
            [(0, 2) => 0, (0, 5) => 4, (0, 6) => 0, (0, 9) => 1],
            'expected rules of negatively filtered vector, $vec * $negFilter';
}, 'Multiplication as a filter';

done-testing;
