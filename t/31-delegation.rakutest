use v6.d;

# use lib <. lib>;
use Math::SparseMatrix;
use Math::SparseMatrix::CSR;
use Math::SparseMatrix::Utilities;
use Test;

# The rules were created with this code
#`[
my $nrow = 5;
my $ncol = 8;
my $density = 0.25;
my $tol = 0.01;

my $matrix1 = generate-random-sparse-matrix(:$nrow, :$ncol, :$density, :$tol):decorated;
$matrix1 = Math::SparseMatrix.new($matrix1, row-names => ('a'...'z').head($nrow));
$matrix1.print;
say $matrix1.rules.raku;
]

my $nrow = 5;
my $ncol = 8;
my @rules = [(0, 7) => 0.65, (1, 0) => 0.24, (1, 1) => 0.81, (1, 3) => 0.68, (1, 4) => 0.34, (2, 0) => 0.68, (2, 2) => 0.28, (2, 5) => 0.43, (3, 0) => 0.32, (4, 1) => 0.67];
my $matrix1 = Math::SparseMatrix::CSR.new(:@rules, :$nrow, :$ncol);
$matrix1 = Math::SparseMatrix.new($matrix1, row-names => ('a' ... 'z').head($nrow));
#$matrix1.print;

plan *;

## 1
subtest {
    isa-ok $matrix1, Math::SparseMatrix, "Expected type after cation";
    is $matrix1.elems,$nrow, "Expected number of elements";
}, 'expected types and sizes';

## 2
subtest {
    my $matrix = $matrix1.clone;
    ok $matrix.unitize;
    is $matrix.unitize.core-matrix.values.max, 1, 'expected max';
    is $matrix.unitize.core-matrix.values.min, 1, 'expected min';
}, 'unitize';

## 3
subtest {
    my $matrix = $matrix1.clone;
    ok $matrix.clip(v-min => 0.3, v-max => 0.65);
    is $matrix.clip(v-min => 0.3, v-max => 0.65).core-matrix.values.max, 0.65, 'expected max';
    is $matrix.clip(v-min => 0.3, v-max => 0.65).core-matrix.values.min, 0.3, 'expected min';
}, 'clip';

## 4
subtest {
    my $matrix = $matrix1.clone;
    my &func = -> $x { $x == 0.81 ?? 100 !! $x };
    ok $matrix.apply-elementwise(&func);
    is $matrix.apply-elementwise({ $_ == 0.81 ?? 100 !! $_ }).core-matrix.values.max, 100, 'expected max';
    is $matrix.apply-elementwise({ $_ == 0.81 ?? 100 !! $_ }).core-matrix.values.min, 0.24, 'expected min';
}, 'apply-elementwise';

done-testing;
